<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>HEX</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
<script>
  const clamp = (x, lowerlimit, upperlimit) => {
    if (x < lowerlimit)
      return lowerlimit;
    if (x > upperlimit)
      return upperlimit;

    return x
  }

  const smoothstep = (edge0, edge1, x) => {
    // Scale, bias and saturate x to 0..1 range
    const val = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    // Evaluate polynomial
    return val * val * (3 - 2 * val);
  }

  const smoothsquare = (f, phi, t) => {
    const tLoop = (t * f + phi + 0.25) % 1;
    return (smoothstep(0.15, 0.35, tLoop) * (1 - smoothstep(0.65, 0.85, tLoop))) * -2 + 1
  }

  const SCALE_FACTOR = 2; // retina, I guess

  const CANVAS_WIDTH = window.innerWidth * SCALE_FACTOR;
  const CANVAS_HEIGHT = window.innerHeight * SCALE_FACTOR;
  const canvas = document.createElement('canvas');
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  canvas.style.width = `${CANVAS_WIDTH / SCALE_FACTOR}px`
  document.body.appendChild(canvas);

  function grayscale(amt = 1) {
    const value = Math.floor((1 - amt * 0.75) * 255)
    return `rgb(${value},${value},${value})`
  }

  function drawHex(centerPoint, radius, openRadius, ctx) {
    // hexPoints.forEach((point) => {
    //   ctx.fillRect(point[0] - 1, point[1] - 1, 2, 2);
    // });
    // innerHexPoints.forEach((point) => {
    //   ctx.fillRect(point[0] - 1, point[1] - 1, 2, 2);
    // });
    const innerRadius = Math.cos(2 * Math.PI / 12) * hexRadius;

    ctx.beginPath();

    ctx.lineWidth = 1;
    // ctx.strokeStyle = grayscale(openRadius / innerRadius)
    ctx.strokeStyle = grayscale(0.5)

    ctx.ellipse(centerPoint[0], centerPoint[1], radius, radius, 0, 0, 2 * Math.PI)
    ctx.stroke();

    ctx.beginPath();

    ctx.ellipse(centerPoint[0], centerPoint[1], openRadius, openRadius, 0, 0, 2 * Math.PI)
    ctx.stroke();


    for (let i = 0; i < 6; i++) {
      const outerPoint1 = [
        centerPoint[0] + Math.cos(i / 6 * 2 * Math.PI) * radius,
        centerPoint[1] + Math.sin(i / 6 * 2 * Math.PI) * radius,
      ]

      const outerPoint2 = [
        centerPoint[0] + Math.cos((i + 1) / 6 * 2 * Math.PI) * radius,
        centerPoint[1] + Math.sin((i + 1) / 6 * 2 * Math.PI) * radius,
      ]

      const innerPoint = [
        centerPoint[0] + Math.cos((i + 0.5) / 6 * 2 * Math.PI) * openRadius,
        centerPoint[1] + Math.sin((i + 0.5) / 6 * 2 * Math.PI) * openRadius,
      ]

      ctx.lineWidth = 1;
      // ctx.strokeStyle = grayscale((1 - openRadius / innerRadius) * 0.9 + 0.2)
      ctx.strokeStyle = grayscale(0.5)

      ctx.beginPath();
      ctx.moveTo(...centerPoint);
      ctx.lineTo(
        centerPoint[0] + Math.cos((i + 0.5) / 6 * 2 * Math.PI) * radius,
        centerPoint[1] + Math.sin((i + 0.5) / 6 * 2 * Math.PI) * radius,
      )
      ctx.stroke();

      ctx.lineWidth = 3;
      ctx.strokeStyle = '#000000'
      ctx.beginPath();
      ctx.moveTo(...outerPoint1);
      ctx.lineTo(...innerPoint);
      ctx.lineTo(...outerPoint2);
      // ctx.lineTo(...innerHexPoints[i]);
      // ctx.closePath();
      ctx.stroke();
    }
  }

  const PERIOD = 10000 * 3;
  const hexRadius = 100;
  const hexInnerRadius = Math.cos(2 * Math.PI / 12) * hexRadius;

  function normalizeT(t, y, x) {
    return t / PERIOD ;
  }

  function draw(t) {
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT)

    const startPoint = [0, 0];
    const gridX = hexRadius * 3;

    ctx.strokeWidth = 2;

    // const colors = ['#000000', '#FFFFFF']

    for (let x = 0; x < CANVAS_WIDTH / gridX; x++) {
      for (let y = 0; y < CANVAS_HEIGHT / hexInnerRadius + 1; y++) {
        const normalizedT = normalizeT(t, y, x);
        const v = smoothsquare(1, 0 ,normalizedT * 2) + y / 25 + x * Math.sin(t / 10000000 * Math.PI);
        const innerHexRadius = hexInnerRadius / 2 * v + hexInnerRadius / 2;

        // const colorT = Math.floor(normalizedT);

        // ctx.strokeStyle = colors[colorT % colors.length]

        // console.log(colorT)

        drawHex(
          [
            startPoint[0] + (x + (y % 2) / 2) * gridX,
            startPoint[1] + y * hexInnerRadius
          ],
          hexRadius,
          innerHexRadius,
          ctx
        );
      }
    }
  }

  function loop(time) {
    draw(time);
    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);
</script>
</body>
</html>